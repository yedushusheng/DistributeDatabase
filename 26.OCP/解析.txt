翻译： 您继承了一个繁忙的 InnoDB OLTP 实例，每个模式有 100 个模式和 100 个活动用户。 。 总数据集大小为 200G，平均架构大小为 2G。 。 数据是暂时的，不会备份，可以轻松重新填充。 。 数据库的性能和响应能力至关重要。 。 数据库实例的查询模式是拆分 90/10 读/写。 。 数据库主机是具有 256G RAM 和 64 个内核的专用服务器。
您的一位同事最近对系统进行了一些更改，用户现在抱怨性能影响。 您的同事可能会执行哪四项配置文件编辑以导致数据库性能下降？ 解析:对于一个繁忙的 oltp 系统,忽略一致性和安全性,响应速度最重要,应该怎样设置会影响 (降低)系统性能? innodb_flush_log_at_trx_commit innodb 专有 0：log buffer 将每秒一次地写入 log file 中，并且 log file 的 flush(刷到磁盘)操作同时进行。该模式下在事 务提交的时候，不会主动触发写入磁盘的操作(最快)。 1：每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，并且 flush(刷到磁盘)中去，该模式为系 统默认(最慢)。 2：每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，但是 flush(刷到磁盘)操作并不会 同时进行。该模式下，MySQL 会每秒执行一次 flush(刷到磁盘)操作。 table_open_cache 当 MySQL 访问一个表时，如果该表在缓存中已经被打开，则可以直接访问缓存；如果还 没有被缓存，但是在 MySQL 表缓冲区中还有空间，那么这个表就被打开并放入表缓冲区； 如果表缓存满了，则会按照一定的规则将当前未用的表释放，或者临时扩大表缓存来存 放，使用表缓存的好处是可以更快速地访问表中的内容。 在 mysql 默认安装情况下，table_cache 的值在 2G 内存以下的机器中的值默认时 256 到 512，如果机器有 4G 内存,则默认这个值是 2048,64 太小了啦 innodb_buffer_pool_instances The number of regions that the InnoDB buffer pool is divided into. For systems with buffer pools in the multi-gigabyte range, dividing the buffer pool into separate instances can improve concurrency, by reducing contention as different threads read and write to cached pages. Each page that is stored in or read from the buffer pool is assigned to one of the buffer pool instances randomly, using a hashing function. Each buffer pool manages its own free lists, flush lists, LRUs, and all other data structures connected to a buffer pool, and is protected by its own buffer pool mutex.
This option only takes effect when setting innodb_buffer_pool_size to 1GB or more. The total buffer pool size is divided among all the buffer pools. For best efficiency, specify a combination of innodb_buffer_pool_instances and innodb_buffer_pool_size so that each buffer pool instance is at least 1GB. 可以开启多个内存缓冲池，把需要缓冲的数据 hash 到不同的缓冲池中，这样可以并行的内 存读写。innodb_buffer_pool_size 设置大一些并且保证每个 pool 实例>1G 可以提高性能 sync_binlog 控制 mysql,binlog 日志刷新策略 · sync_binlog=0: Disables synchronization of the binary log to disk by the MySQL server. Instead, the MySQL server relies on the operating system to flush the binary log to disk from time to time as it does for any other file. This setting provides the best performance, but in the event of a power failure or operating system crash, it is possible that the server has committed transactions that have not been synchronized to the binary log. · 关闭日志同步 · sync_binlog=1: Enables synchronization of the binary log to disk before transactions are committed. This is the safest setting but can have a negative impact on performance due to the increased number of disk writes. In the event of a power failure or operating system crash, transactions that are missing from the binary log are only in a prepared state. This permits the automatic recovery routine to roll back the transactions, which guarantees that no transaction is lost from the binary log. · 每次提交都同步(慢) · sync_binlog=N, where N is a value other than 0 or 1: The binary log is synchronized to disk after N binary log commit groups have been collected. In the event of a power failure or operating system crash, it is possible that the server has committed transactions that have not been flushed to the binary log. This setting can have a negative impact on performance due to the increased number of disk writes. A higher value improves performance, but with an increased risk of data loss. · N 次提交都同步
innodb_flush_method 这个参数控制着 innodb 数据文件及 redo log 的打开、刷写模式，对于这个参数，文档上是 这样描述的： 有三个值：fdatasync(默认)，O_DSYNC，O_DIRECT 默认是 fdatasync，调用 fsync()去刷数据文件与 redo log 的 buffer 为 O_DSYNC 时，innodb 会使用 O_SYNC 方式打开和刷写 redo log,使用 fsync()刷写数据文 件为 O_DIRECT 时，innodb 使用 O_DIRECT 打开数据文件，使用 fsync()刷写数据文件跟 redo log 具体的取值跟硬件配置和工作负载相关，最好做一次压测来决定。不过通常来说，linux 环 境下具有 raid 控制器和 write-back 写策略，o_direct 是比较好的选择；如果存储介质是 SAN，那么使用默认 fsync 或者 osync 或许更好一些。 query_cache_size 对于使用 MySQL 的用户，对于这个变量大家一定不会陌生。前几年的 MyISAM 引擎优化中， 这个参数也是一个重要的优化参数。但随着发展，这个参数也爆露出来一些问题。 机器的内存越来越大，人们也都习惯性的把以前有用的参数分配的值越来越大。这个参数加 大后也引发了一系列问题。我们首先分析一下 query_cache_size 的工作原理： 一个 SELECT 查询在 DB 中工作后，DB 会把该语句缓存下来，当同样的一个 SQL 再次来到 DB 里调用时，DB 在该表没发生变化的情况下把结果从缓存中返回给 Client。 这里有一个关建点，就是 DB 在利用 Query_cache 工作时，要求该语句涉及的表在这段时间 内没有发生变更。那如果该表在发生变更时，Query_cache 里的数据又怎么处理呢？首先要 把 Query_cache 和该表相关的语句全部置为失效，然后在写入更新。那么如果 Query_cache 非常大，该表的查询结构又比较多，查询语句失效也慢，一个更新或是 Insert 就会很慢， 这样看到的就是 Update 或是 Insert 怎么这么慢了。 所以在数据库写入量或是更新量也比较大的系统，该参数不适合分配过大。而且在高并发， 写入量大的系统，建系把该功能禁掉。 tmp_table_size 控制内存临时表的最大值,超过限值后就往硬盘写，写的位置由变量 tmpdir 决定 max_heap_table_size 用户可以创建的内存表(memory table)的大小.这个值用来计算内存表的最大行数值。
A. table_open_cache = 64(降低性能) B. innodb_buffer_pool_instances=64; innodb_buffer_pool_size=200G(在一个独立的只 使用 InnoDB 引擎的 MySQL 服务器中，根据经验，推荐设置 innodb-buffer-pool-size 为服 务器总可用内存的 80%。提升性能) C. log_bin=mysql–bin; Innodb_flush_log_at_trx_commit=1(降低性能) D. sync_binlog=10(默认值是 1 但是 0 最快所以认为降低性能) E. innodb_flush_method=O_DIRECT(按说会快点?) F. max_heap_table_size = 2G; tmp_table_size=2G(默认值 60M 提升性能) G. query_cache_size = 2G; query_cache_enabled=1(太大了,会导致经常置为失效,256m 即可,降低性能) H. innodb_flush_log_at_trx_commit=0(提升性能) 提升性能的为 BFH 降低性能的为 ACDG