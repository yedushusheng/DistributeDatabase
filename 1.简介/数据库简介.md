# 概述

简单的说，数据库（因为Database）就是一个存放数据的仓库，这个仓库是按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织、存储的，我们可以通过数据库提供的多种方式来管理数据库里的数据。

更简单形象的理解，数据库和我们生活中存放杂物的储物间仓库性质一样，区别只是存放的东西不同，杂物间存放实体的物件，而数据库里存放的是数据。

数据库诞生于距距现在大概六十多年前，随着信息技术的发展和人类社会的不断进步，特别是2000年以后，数据库不在仅仅是存储和管理数据了，而转变成用户所需要的各种数据管理方式。数据库有很多种类和功能，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库系统都在各方面得到了广泛的应用。

# 分类

## **关系/非关系型数据库**

按照早期的数据库理论，比较流行的数据库模型有三种，分别为层次式数据库、网络式数据库和关系型数据库（前两者已经基本消失）。而当今的互联网中，最常用的数据库模型主要是两种，即关系型数据库和非关系型数据库。

### **关系型数据库**

#### 概述

关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联表的表格分类、合并、连接或选取等运算来实现数据的管理。

关系型数据库诞生距今已有40多年了，从理论产生发展到现实产品，例如：MySQL和Oracle数据库。Oracle在数据库领域里上升到了霸主地位，形成每年高达数百亿美元的庞大产业市场，而MySQL也是不容忽视的数据库，以至于被Oracle重金收购（先被SUN收购，然后SUN被Oracle收购，据说MySQL卖了10亿美金）。

#### 分类

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsD9E8.tmp.jpg) 

##### Oracle数据库

Oracle前生叫SDL，由Larry Ellison和另外两个编程人员在1977创办，他们开发了自己的拳头产品，在市场上大量销售，1979年，Oracle公司引入了第一个商用SQL关系型数据库管理系统。Oracle公司是最早开发关系型数据库的厂商之一，其产品支持最广泛的操作系统平台。目前Oracle关系型数据库产品的市场占有率数一数二。

Oracle公司是目前全球最大的数据库软件公司，也是近年业务增长极为迅速的软件提供与服务商。

主要应用范围：传统大企业，大公司，政府，金融，证券等等。

版本升级：Oracle8i，Oracle9i，Oracle10g，Oracle11g，Oracle12c

##### MySQL数据库

MySQL数据库是一个中小型关系型数据库管理系统，软件开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购，后Sun公司又被oracle公司收购。目前MySQL被广泛地应用在Internet上的大中小型网站中。由于体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多大中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库，甚至国内知名的淘宝网页选择弃用ORACLE而更换为更开放的MySQL。

MySQL数据库主要应用范围：互联网领域、大中小型网站，游戏公司，电商平台等等。

 

##### MariaDB

MariaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用CPL授权许可。开发这个MariaDB数据库分支的可能原因之一是：甲骨文公司收购了MySQL之后，有将MySQL闭源的潜在风险，因此MySQL开源社区采用分支的方式来避开这个风险。（CentOS7已经将集成的MySQL替换为了MariaDB）

开发MariaDB数据库的目的是完全兼容MySQL数据库，包括API和命令行，使之能轻松的成为MySQL的代替品。在存储引擎方面，使用XtraDB来代替MySQL的InnoDB。MariaDB由MySQL的创始人Michael Widenius主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入了Oracle的手中。MariaDB数据库的名称来自MySQL的创始人Michael Widenius的女儿Maria的名字。

MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，它使用Percona的XtraDB。这个版本还包括了PrimeBase XT和FederatedX存储引擎。

MariaDB数据库直到5.5八本，均依照MySQL的版本发行。因此，使用MariaDB5.5的人会从MySQL5.5中了解到MariaDB的所有功能。

##### SQL Server

Microsoft SQL Server是微软公司开发的大型关系型数据库系统。SQL Server的功能比较全面，效率高，可以作为中型企业或者单位的数据库平台。SQL Server可以与Windows操作系统紧密集成，不论是应用程序开发速度还是系统事务处理运行速度，都能得到较大的提升。对于在Windows品台上开发的各种企业级信息管理系统来说，不论是C/S架构还是B/S架构，SQL Server都是一个很好的选择。SQL Server的缺点是只能在Windows系统下运行。

主要应用范围：部分企业电商，使用windows服务器平台的企业。

##### Access

美国Microsoft公司于1994年推出的微机数据库管理系统。它具有界面友好、易学易用、开发简单、接口灵活等特点，是典型的新一代桌面关系型数据库管理系统。它结合了Microsoft Jet Database Engine和图形用户界面两项特点，是Microsoft Office的成员之一。Access能够存取Access/Jet、Microsoft SQL Server、Oracle，或者任何ODBC兼容数据库的资料。

Access是入门级小型桌面数据库，性能安全性都很一般。可供个人管理或小型网站使用

##### 其他数据库

DB2，PostgreSQL，Informix，Sybase等。

### **非关系型数据库**

#### 概述

非关系型数据库也被称为NoSQL数据库，NoSQL的本意是“Not Only SQL”，指的是非关系型数据库，而不是“No SQL”的意思（没有SQL语句？），因此，NoSQL的产生并不是要彻底否定关系型数据库，而是作为传统关系型数据库的一个有效补充。NoSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能。

随着互联网web2.0（以前的基本上是静态网页，而现在是交互的网站）网站的兴起，传统的关系型数据库在应付web2.0网站，特别是对于规模日益扩大的海量数据，超大规模和高并发的微博、微信、SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：传统的关系型数据库IO瓶颈、性能瓶颈都难以有效突破，于是开始出现了大批针对特定场景，以高性能和使用便利为目的的功能特异化的数据库产品，NoSQL（非关系型）类的数据库就是在这样的情景中诞生并得到了非常迅速的发展。NoSQL不将数据的一致性作为重点，或者是作为次重点。

NoSQL是非关系型数据库的广义定义。它打破了长久以来关系型数据库与ACID理论大统一的局面。NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。在大数据存取上具备关系型数据库无法比拟的性能优势。该术语（NoSQL）在2009年初得到了广泛认同。当今的应用体系结构需要数据存储在横向伸缩性上能够满足需求。而NoSQL存储就是为了实现这个需求而诞生的。

#### 分类

##### 键值（Key-Value）存储数据库

键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据，因为使用key主键访问，所以会获得很高的性能及扩展性。

键值（Key-Value）数据库主要是使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。

典型产品：Memcached、Redis、MemcacheDB、Berkeley DB

##### 列存储（Column-oriented）数据库

列存储数据库将数据存在列族（column family）中，一个列族存储经常被一起查询的相关数据。举个例子，如果我们有一个Person类，我们通常会一起查询他们的姓名和年龄，而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另外一个列族中。

这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是他们的特点是指向了多个列。这些列是由列家族来安排的。

典型产品：Hbase、Cassandra

##### 面向文档数据库

文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。

面向文档数据库会将数据以文档的形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。

典型产品：MongoDB、CouchDB

##### 图形数据库

图形数据库允许我们将数据已图的方式存储。实体会被作为定点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs，Apple和Next，则会有两个”Founded by”的边将Apple和Next连接到Steve Jobs。

图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。

典型的产品有：Neo4J、InfoGrid。

## **行/列数据库**

### **列式数据库**

列式存储(Column-based)是相对于传统关系型数据库的行式存储(Row-based)来说的。简单来说两者的区别就是如何组织表。

将表放入存储系统中有两种方法，而我们绝大部分是采用行存储的。行存储法是将各行放入连续的物理位置，这很像传统的记录和文件系统。列存储法是将数据按照列存储到数据库中，与行存储类似，下图是两种存储方法的图形化解释。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsD9F9.tmp.jpg) 

### **行式数据库**

应用行式存储的数据库系统称为行式数据库，同理应用列式存储的数据库系统称为列式数据库。随着列式数据库的发展，传统的行式数据库加入了列式存储的支持，形成具有两种存储方式的数据库系统。

传统的关系型数据库，如Oracle、DB2、MySQL、SQL SERVER等采用行式存储法，当然传统的关系型数据库也在不断发展中。随着Oracle 12c推出了in memory组件，使得Oracle数据库具有了双模式数据存放方式，从而能够实现对混合类型应用的支持：传统的以行形式保存的数据满足OLTP应用；列形式保存的数据满足以查询为主的OLAP应用。

新兴的Hbase、HP Vertica、EMC Greenplum等分布式数据库采用列式存储，当然这些数据库也有对行式存储的支持比如HP Vertica。

随着传统关系型数据库与新兴的分布式数据库不断的发展，列式存储与行式存储会不断融合，数据库系统会呈现双模式数据存放方式，这也是商业竞争的需要。

列式存储的主要优点之一就是可以大幅降低系统的I/O，尤其是在海量数据查询时，I/O向来是系统的主要瓶颈之一。

### **区别**

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsD9FA.tmp.jpg) 

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsD9FB.tmp.jpg) 

### **应用场景**

在比较了行式数据库与列式数据库之后，我们更关心的是如何根据业务场景需要选择对应的数据库系统。

行式更适合OLTP，比如传统的基于增删改查操作的应用。列式更适合OLAP，非常适合于在数据仓库领域发挥作用，比如数据分析、海量存储和商业智能；涉及不经常更新的数据。

由于设计上的不同，列式数据库在并行查询处理和压缩上更有优势。而且数据是以列为单元存储，完全不用考虑数据建模或者说建模更简单了。要查询计算哪些列上的数据，直接读取列就行。

最后我们需要务实的指出，没有万能的数据库，列式数据库也并非万能，只不过给DBA提供了更多的选择，DBA需根据自己的应用场景自行选择。

## **数据库应用**

一般来说，可将数据库的应用类型分为OLTP（OnLine Transaction Processing ，联机事务处理）和OLAP（OnLine Analysis Processing，联机分析处理）两种。OLTP是传统关系型数据库的主要应用，其主要面向基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。

### **OLTP**

OLTP也被称为面向交易的处理系统，其基本特征是可以立即将顾客的原始数据传送到计算中心进行处理，并在很短的时间内给出处理结果，这个过程的最大优点是可以即时地处理输入的数据、及时地回答，因此OLTP又被称为实时系统（Real Time System）。衡量OLTP系统的一个重要性能指标是系统性能，具体体现为实时响应时间（Response Time），即从用户在终端输入数据到计算机对这个请求做出回复所需的时间。OLTP数据库旨在使事务应用程序仅完成对所需数据的写入，以便尽快处理单个事务。

OLTP数据库通常具有以下特征：

支持大量并发用户定期添加和修改数据。

反映随时变化的单位状态，但不保存其历史记录。

包含大量数据，其中包括用于验证事务的大量数据。

具有复杂的结构。

可以进行优化以对事务活动做出响应。

提供用于支持单位日常运营的技术基础结构。

个别事务能够很快地完成，并且只需要访问相对较少的数据。OLTP系统旨在处理同时输入的成百上千的事务。

### **OLAP**

OLAP数据库分为一个或多个多维数据集，每个多维数据集都由多维数据集管理员组织和设计，以适应用户检索和分析数据的方式，从而更易于创建和使用所需的数据透视表和数据透视图。

OLAP是共享多维信息的、针对特定问题的联机数据访问和分析的快速软件技术。它通过对信息的多种可能的观察形式进行快速、稳定一致和交互性的存取，允许管理决策人员对数据进行深入观察。决策数据是多维数据，是决策的主要内容。OLAP专门用于支持复杂的分析操作，侧重对决策人员和高层管理人员的决策支持，可以根据分析人员的要求快速、灵活地进行大数据量的复杂查询处理，并且以一种直观易懂的形式将查询结果提供给决策人员，以便他们准确掌握企业（公司）的经营状况、了解对象的需求、制定正确的方案。

OLAP具有灵活的分析功能、直观的数据操作和分析结果可视化表示等突出优点，从而使用户对基于大量复杂数据的分析变得轻松而高效，利于用户迅速做出正确判断。OLAP可用于证实人们提出的复杂假设，是以图形或表格的形式来表示的对信息的总结。OLAP并不将异常信息标记出来，采取的是一种知识证实的方法。

OLAP的主要特点是直接仿照用户的多角度思考模式，预先为用户组建多维的数据模型。在这里，维指的是用户的分析角度，例如对销售数据的分析，时间周期是一个维度，产品类别、分销渠道、地理分布、客户群类也分别是不同的维度。一旦多维数据模型建立完成，用户可以快速地从各个分析角度获取数据，也能动态地在各个角度之间切换数据或者进行多角度综合分析，具有极大的分析灵活性。这也是OLAP在近年来被广泛关注的根本原因。OLAP从设计理念和真正实现上都与旧有的管理信息系统有着本质的区别。

下面介绍一下OLAP的基本概念：

维（Dimension）：是用户观察数据的特定角度，是问题的一类属性，属性集合构成一个维（时间维、地理维等）。

维的层次（Level）：用户观察数据的某个特定角度（即某个维）还可能存在细节程度不同的各个描述方面（时间维包括日期、月份、季度、年）。

维的成员（Member）：即维的一个取值，是数据项在某个维中位置的描述，如“某年某月某日”是在时间维上的位置描述。

度量（Measure）：多维数组的取值。OLAP的基本多维分析操作有钻取（Drill-up和Drill-down）、切片（Slice）和切块（Dice）以及旋转（Pivot）等。

钻取：改变维的层次，变换分析的粒度。它包括向下钻取（Drill-down）和向上钻取（Drill-up）/上滚（Roll-up）。向上钻取是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数；而向下钻取则相反，从汇总数据深入到细节数据进行观察或增加新维。

切片和切块：在一部分维上选定值后，关心度量数据在剩余维上的分布。如果剩余的维只有两个，则是切片；如果有三个或以上，则是切块。

旋转：变换维的方向，即在表格中重新安排维的放置（如行列互换）。

**OTHER**

除了传统的OLTP、OLAP类，近些年来针对数据的使用又有些新特点，我将其归入了“其他”类。

**多模**

随着业务“互联网化”和“智能化”的发展以及架构 “微服务”和“云化”的发展，应用系统对数据的存储管理提出了新的标准和要求，数据的多样性成为突出的问题。早期数据库主要面对结构化数据的处理场景。后面随着业务的发展，逐渐产生了对非结构化数据的处理需求。包括结构化数据、半结构化(JSON、XML等)数据、文本数据、地理空间数据、图数据、音视频数据等。多模，正是指单一数据库支持多种类型数据的存储与处理。

**流式**

流式处理(实时计算)，是来源于对数据加工时效性的需求。数据的业务价值随着时间的流失而迅速降低，因此在数据发生后必须尽快对其进行计算和处理。传统基于周期类的处理方式，显然无法满足需求。随着移动互联网、物联网和传感器的发展导致大量的流式数据产生。相应地出现了专有的流式数据处理平台，如Storm、Kafka等。近些年来，很多数据库开始支持流式数据处理，例如MemSQL、PipelineDB。有些专有流式数据处理平台开始提供SQL接口，例如KSQL基于Kafka提供了流式SQL处理引擎。

**高阶**

随着对数据使用的深入，数据的使用不再仅仅以简单的增删改查或分组聚合类操作，而对于其更为高阶的使用也逐步引起大家的重视。例如使用机器学习、统计分析和模式识别等算法，对数据进行分析等。

### **区别**

OLTP主要执行基本的、日常的事务处理，比如在银行存取一笔款，就是一个事务交易。OLTP的特点一般有：实时性要求高。查询的数据量不是很大。交易一般是确定的，所以OLTP是对确定性的数据进行存取。并发性要求高，并且严格要求事务的完整性、安全性。

OLAP是数据仓库系统的主要应用，其典型的应用就是复杂的动态报表系统。OLAP的特点一般有：

实时性要求不是很高，很多应用最多每天更新一次数据。

数据量大。因为OLAP支持的是动态查询，用户要通过对很多数据的统计才能得到想要知道的信息，如时间序列分析等，所以处理的数据量很大。

因为重点在于决策支持，所以查询一般是动态的，也就是说允许用户随时提出查询的要求。因此，在OLAP中通过一个重要概念“维”来搭建一个动态查询的平台（或技术），供用户自己决定需要知道的信息。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsD9FC.tmp.jpg) 

**数据处理模式**

面对上述复杂多变的应用场景，数据应用的多种类别，是由单一平台处理，还是由不同平台来处理呢？一般来说，专有系统的性能将比通用系统性能高一到两个数量级，因而不同的业务应采用不同的系统。但正如古人说“天下大势、分久必合、合久必分”，在数据处理领域也有一种趋势，由单一平台来处理。这里选择的核心在于如何来辩证看待需求和技术。它们是一对矛盾体，当这对矛盾缓和时，数据处理领域将更趋向于整合；而当这对矛盾尖锐时，数据处理领域将趋于分散。就软硬件技术发展现状和当前需求来看，未来整合的趋势更为明显。集成数据平台将能满足绝大多数用户的场景，只有极少数企业需要使用专有系统来实现其特殊的需求。

**分散式（专有平台）**

目前比较常规的方式，是采用多个专有平台，来针对不同场景进行数据处理。因此是跨平台的，因此是有个数据传输的过程。这之中会带来两个问题：数据同步、数据冗余。数据同步的核心是数据时效性问题，过期的数据往往会丧失价值。常见的做法如下：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA0C.tmp.jpg) 

OLTP系统中的数据变化，通过日志的形式暴露出来；通过消息队列解耦传输；后端的ETL消费拉取，将数据同步到OLAP中。整个链条较长，对于时效性要求较高的场景是个考验。此外，数据在链条中流动，是存在多份的数据冗余保存。在常规的高可用环境下，数据会进一步保存多份。因此这里面隐藏了比较大的技术、人力成本以及数据同步成本。而且横跨如此之多的技术栈、数据库产品，每个技术栈背后又需要单独的团队支持和维护，如DBA、大数据、基础架构等。这些都蕴含着巨大的人力、技术、时间、运维成本。正是出于在满足各种业务需求的同时，提高时效性，减低数据冗余、缩短链条等，收敛技术栈就变得很重要。这也是通用类平台解决方案，诞生的出发点。

**集中式/HTAP（通用平台）**

用户厌倦了为不同的数据处理采用不同的数据处理系统，更倾向于采用集成数据处理平台来处理企业的各种数据类型。对于融合了联机事务处理和联机实时分析的场景，也就是HTAP。

在互联网浪潮出现之前，企业的数据量普遍不大，特别是核心的业务数据，通常一个单机的数据库就可以保存。那时候的存储并不需要复杂的架构，所有的线上请求 (OLTP, Online Transactional Processing) 和后台分析 (OLAP, Online Analytical Processing) 都跑在同一个数据库实例上。

随着互联网的发展，企业的业务数据量不断增多，单机数据库的容量限制制约了其在海量数据场景下的使用。因此在实际应用中，为了面对各种需求，OLTP、OLAP 在技术上分道扬镳，在很多企业架构中，这两类任务处理由不同团队完成。当物联网大数据应用不断深入，具有海量的传感器数据要求实时更新和查询，对数据库的性能要求也越来越高，此时，新的问题随之出现：

1、OLAP 和 OLTP 系统间通常会有几分钟甚至几小时的时延，OLAP 数据库和 OLTP 数据库之间的一致性无法保证，难以满足对分析的实时性要求很高的业务场景。

2、企业需要维护不同的数据库以便支持两类不同的任务，管理和维护成本高。

因此，能够统一支持事务处理和工作负载分析的数据库成为众多企业的需求。在此背景下，由Gartner提出的HTAP（混合事务/分析处理，Hybrid Transactional/Analytical Processing）成为希望。基于创新的计算存储框架，HTAP数据库能够在一份数据上同时支撑业务系统运行和OLAP场景，避免在传统架构中，在线与离线数据库之间大量的数据交互。此外，HTAP基于分布式架构，支持弹性扩容，可按需扩展吞吐或存储，轻松应对高并发、海量数据场景。

此类通用平台方案具备下面优点：

通过数据整合避免信息孤岛，便于共享和统一数据管理。

基于SQL的数据集成平台可提供良好的数据独立性，使应用能专注于业务逻辑，不用关心数据的底层操作细节。

集成数据平台能提供更好的实时性和更全的数据，为业务提供更快更准的分析和决策。

能够避免各种系统之间的胶合，企业总体技术架构简单，不需要复杂的数据导入/导出等，易于管理和维护。

便于人才培养和知识共享，无须为各种专有系统培养开发、运维和管理人才。

**分片方式**

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA1D.tmp.jpg) 

**分库分表中间件**

中间件模式SQL解析、执行计划优化等在中间件与数据库中重复工作，效率相对比较低。

**NewSQL**

NewSQL是一种新方式关系数据库，意在整合RDBMS所提供的ACID事务特性（即原子性、一致性、隔离性和可持久性），以及NoSQL提供的横向可扩展性。

NoSQL数据库给出了一种易于实现可扩展性和更好性能的解决方案，解决了CAP理论中的 A（可用性）和 P（分区容错性）上的设计考虑。但这意味着，在很多NoSQL设计中实现为最终一致性，摈弃了RDBMS提供的强一致性及事务的ACID属性。

NoSQL数据库使用了不同于关系模型的模型，例如键值模型、文档模型、宽列模型和图模型等。采用这些模型的NoSQL数据库并不提供规范化，本身在设计上是无模式的。大多数NoSQL数据库支持自动分区，无需开发人员干预即可轻松实现水平扩展。

NoSQL适用于可接受最终一致性的部分应用，例如社交媒体。用户并不关注看到的是否为不一致的数据库视图，并且考虑到数据的状态更新、发推文等，强一致性也并非必要的。但是，NoSQL数据库不宜用于对一致性要求高的系统，例如电子商务平台。

NewSQL系统的提出，正是为了满足整合NoSQL和RDBMS特性的需求。其中，NoSQL提供了可扩展性和高可用性，传统RDBMS提供了关系模型、ACID 事务支持和SQL。用户已不再考虑一招能解决所有问题（one-size-fits-all）的方案，逐渐转向针对OLTP等不同工作负载给出特定数据库。大多数NewSQL数据库做了全新的设计，或是主要聚焦于OLTP，或是采用了OLTP/OLAP的混合架构载的全新设计。

传统的RDBMS架构从一开始设计时并未考虑分布式系统，而是在分布式需求出现后，才考虑在最初的设计之添加支持分布式的设计。由于RDBMS实现了规范化模式，而非NoSQL那样的聚合表单，因此RDBMS中必须引入一些复杂的概念，才能在支持可扩展的同时保持一致性需求。由此，为支持RDBMS中的横向扩展，人们提出了手动分片和主从架构。

但是，RDBMS为实现横向扩展而在性能上做出了很大让步。这是因为连接运算中需要在各个节点间移动数据以实现聚合，运算实现代价增大。另外，数据维护开销变得更为耗时。为保持RDBMS的性能，一些企业推出了复杂的系统和产品。但是当前，人们依然并不认为传统RDBMS本身支持可扩展。

NewSQL数据库为云时代而生，因此它从一开始就考虑了分布式架构。

**Cloud Native DB**

参考：

https://zhuanlan.zhihu.com/p/87742609

# SQL

## **分类**

### **DDL**

DDL：数据定义语言

### **TPL**

TPL：事务处理语言

### **DCL**

DCL：数据控制语言

### **DML**

DML：数据操作语言

## **作用**

1、 增加数据库处理效率，减少应用响应时间；

2、 减少数据库服务器负载，增加服务器稳定性；

3、 减少服务器间通讯的网络流量。

# Oracle

## **架构**

Oracle Server包括数据库（Database）和实例（Instance）两大部分，两者相互独立。数据库由数据文件 、控制文件和日志文件组成，实例由内存池和后台进程组成，示意图如下：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA1E.tmp.jpg) 

一台Oracle Server可创建多个Database，不同的Database之间相互独立。每个Database有属于自己的全套相关文件，如：密码文件，参数文件，数据文件，控制文件和日志文件

Database由一系列物理文件（如二维表文件）组成。用户不能直接读取Database中的内容，必须通过Oracle instance才能读取，一个Instance只能连接一个Database，但是一个Database可以被多个Instance连接。

各功能组件说明如下：

1、用户连接进程

用户连接进程是连接用户和Oracle Instance的桥梁。包括：用户进程、服务进程和PGA

● 用户进程User Process

当一个Database User请求连接到Oracle Server时，Oracle Server创建的User Process。

● Server Process服务进程

用于处理Database User和Oracle Server之间的连接。

● 程序全局区PGA

PGA：由Server Process分配，用于当前User Session的内存区，不同的用户拥有不同的PGA。PGA包含了Server Process数据和控制信息的内存区域。包括栈空间、 Session Info、 私有SQL区。

2、SGA（System Global Area）

SGA与Oracle性能息息相关，在Instance启动时被分配，关闭时被释放。主要包含如下几种数据结构：

● 数据库缓冲区（Database buffer cache）

oracle 执行SQL语句的区域。当进行数据更新或数据查询时，用户执行的SQL语句不会直接对磁盘上的数据文件进行更改操作，而是首先将数据文件复制到数据库缓冲区缓存，再更改或查询缓存中的副本。此外，被频繁访问的数据块会存在于数据库缓冲区缓存中。

● 日志缓冲区（Redo log Buffer）

用于短期存储redo log。

● 共享池（Shared Pool）

用于缓存所有频繁执行的代码和频繁访问的对象定义。共享池内有下列三种数据结构：

库缓冲（library cache）：存储最近执行的代码

数据字典缓存（data dictionary cache）：存储最近使用的对象定义

PL/SQL缓冲区（PL/SQL buffer）：用于存储过程、函数、打包的过程、打包的函数、对象类型定义和触发器。

● 大型池（Large Buffer）

用于共享的服务器进程。

● JAVA池（Java Buffer）：

只有当应用程序需要在数据库中运行java存储程序时，才需要java池。

3、后台进程

后台进程主要用于数据库管理 ，是Oracle Instance和Oracle Database的联系纽带，分为核心进程和非核心进程。

\1) 核心进程：

● 数据库写入进程（DBWn）

Server process连接Oracle后，通过数据库写进程(DBWn)将数据缓冲区中的“脏缓冲区” 的数据块写入到数据文件；

● 检查点进程(CKPT)

Checkpoint (CKPT)检查点进程主要用于更新数据文件头，更新控制文件和触发DBWn数据库写进程。

● 进程监视进程（PMON）

当后台进程执行失败后负责清理数据库缓存和闲置资源，是Oracle的自动维护机制。 

● 系统监视进程（SMON）

用途如下：

当数据库实例崩溃时，用于数据库实例的自动恢复。

清除作废的排序临时段，回收整理碎片，合并空闲空间，释放临时段，维护闪回的时间点。

● 重做日志文件和日志写入进程

用于记录数据库的改变和记录数据库被改变之前的原始状态，当满足以下条件时，激活LGWR： 

提交指令

日志缓冲区超过1/3

每三秒

每次DBWn执行之前

\2) 非核心进程

● 归档进程（ARCn）

是可选的后台进程，当数据库处于ArchiveLog模式时，自动归档redo log，并保存数据库的所有修改记录。

SGA（System Global Area）和后台进程组成Instance。 

4、存储结构

存储结构可从物理结构和逻辑结构两方面理解。

\1) 物理结构

Database物理结构：是Database在操作系统中的文件集合，即：磁盘上的物理文件，主要由数据文件、控制文件、重做日志文件、归档日志文件、参数文件、口令文件组成。

数据文件、重做日志文件、控制文件、跟踪文件、警告文件属于数据库文件

● Data Files

数据文件是数据的存储仓库，数据被使用时才被调入内存中的。

● Redo Log Files

重做日志文件包含对数据库所做的更改操作记录，在Oracle发生故障时能够恢复数据。

● Control Files 

控制文件包含维护和验证数据库完整性的必要的信息。例如，控制文件用于识别数据文件和重做日志文件，一个数据库至少需要一个控制文件。

● 跟踪文件 (Trace Files)

在instance 中运行的每一个后台进程都有一个跟踪文件（trace file）与之相连。Trace file记载后台进程所遇到的重大事件的信息。

● 警告日志（ Alert Log）

是一种特殊的跟踪文件，每个数据库都有一个跟踪文件，同步记载数据库的消息和错误。

参数文件、口令文件、归档文件属于非数据库文件。

● Parameter File

实例参数文件，当启动oracle实例时，SGA结构会根据此参数文件的设置内存，后台进程会据此启动。

● Password File

用户通过提交username/password来建立会话，Oracle根据存储在数据字典的用户定义对用户名和口令进行验证。

● 归档文件

是重做日志文件的脱机副本，这些副本可能对于从介质失败中进行恢复很必要。

\2) 逻辑结构

● 表空间

用于存储数据库对象的逻辑空间，是信息存储的最大逻辑单位，是一系列数据文件的集合。一个数据库可以由多个表空间组成，每个表空间包括多个段。

● 段：

是对象在数据库中占用的空间。段是区的集合

● 区：

是为数据一次性预留的一个较大的存储空间，区是块的集合

● 块：

ORACLE最基本的存储单位，在建立数据库的时候指定，并被映射到磁盘块。

\3) 逻辑空间到物理空间的映射

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA1F.tmp.jpg) 

## **Oracle RDBMS的运行过程** 

1、User访问Oracle Server之前提交一个请求(包含了db_name、password、instance_name、username等信息)；

2、Oracle Server接收到请求并通过Password File的验证后，分配SGA内存池，启动后台进程同时创建并启动实例；

3、启动实例之后，User Process与Server Process建立Connect；

4、Server process和Oracle Instance建立Sesscion，随后接收用户请求，执行相关操作；

## **写SQL语句的执行过程**

1、用户执行SQL语句，Server process收到后，将SQL语句送到Instance，再将SQL语句载入数据库缓冲区。

2、Server Process通知Oracle Database将与SQL语句相关的数据块副本加载到缓冲区中。

3、在数据库缓存区执行SQL语句，修改数据文件副本，形成“脏缓冲区”

4、CKPT检查到”脏缓冲区”，调用DBWn数据库写进程，

5、在DBWn运行之前，先运行了LGWR，将数据文件的原始状态和数据库的改变记录到Redo Log Files

6、运行DBWn，将“脏缓冲区的内容写入到数据文件”

7、同时CKPT修改控制文件和数据文件头

8、SMON回收不必要的空闲资源

9、返回结果给用户

 

## **高可用性架构**

### **RAC**

1、Oracle RAC（Real Application Clusters）

RAC是Oracle数据库的一个群集解决方案，包括计算层和存储层。如下图所示：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA30.tmp.jpg) 

\1) 存储层——共享存储

Oracle RAC的核心是共享磁盘子系统，集群中所有节点必须能够访问所有数据文件、重做日志文件、控制文件和参数文件，因此，这些文件必须存放在共享存储中。常用的共享存储方式有OCFS、OCFS2、RAW、NFS、ASM 等。说明如下：

OCFS（Oracle Cluster File System） 和 OCFS2 都是文件系统，和 NFS 一样，提供集群环境共享存储的文件系统。

RAW 裸设备也是一种存储方式。把共享存储映射到 RAW Device，Oracle在存储数据时，选择 RAW device存储即可。但相对于文件系统来说, RAW不直观，不便于管理，而且有数量的限制，现已被OCFS取代。

ASM 是一种数据库存储的方案，并不是 cluster 的方案，使用 ASM 时，还需使用OCFS/OCFS2 或RAW。

 

\2) 计算层

计算层至少需要两台以上的服务器，在每台服务器上安装集群软件和Oracle的 RAC 组件，从逻辑结构上看，每个节点都有一个独立的实例，这些实例访问同一个数据库。节点之间通过集群软件的通信层（Communication Layer）进行通信，利用高速缓存合并技术，实现集群中各节点缓存的高速同步，使得集群中的每个实例，都保留了一份相同的数据库 cache。从而最大限度地低降低磁盘I/O。因此，RAC有如下特点：

每一个节点的实例都有自己的 SGA；

每一个节点的实例都有自己的后台进程

每一个节点的实力都有自己的 redo logs

每一个节点的实例都有自己的 undo 表空间

所有节点都共享一份 datafiles 和 controlfiles

### **Data Guard**

2、Data Guard

在Data Gurad 环境中，至少有两个数据库，一个主库（Primary Database）处于Open 状态，另一个备库（Standby Database）处于standby状态。

备库又分物理库和逻辑库。物理库和主库完全一样，通过REDO应用来保持与主库的数据一致性，支持只读服务；逻辑库通过SQL应用，在备库端执行和主库同样的SQL语句，以此来保持与主库的数据一致，因此文件的物理结构（甚至数据的逻辑结构）都可以与主库不一致。逻辑库支持读写服务。

Data Guard适合多机房方案，实际部署时，主库部署在主机房，备库部署在其他机房。

# MySQL

## **架构**

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA40.tmp.jpg) 

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA41.tmp.jpg) 

1、连接器（Connectors）

MySQL向外提供的接口，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。

2、管理服务组件和工具组件(Management Service & Utilities)

提供对MySQL的集成管理，如备份(Backup),恢复(Recovery),安全管理(Security)等

3、连接池组件(Connection Pool)

负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。

4、SQL接口组件(SQL Interface)

接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。

5、查询分析器组件(Parser)

首先分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。

6、优化器组件（Optimizer）

对SQL命令按照标准流程进行优化分析。

7、缓存主件（Caches & Buffers）

缓存和缓冲组件

8、MySQL存储引擎

MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的。

因MySQL的开源性，允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。因此，MySQL支持的存储引擎种类较多，可以分为官方存储引擎和第三方存储引擎。

当前，MySQL的存储引擎有MyISAM、InnoDB、NDB、Archive、Federated、Memory、Merge、Parter、Community、Custom等。其中，比较常用的存储引擎包括InnoDB、MyISAM和Momery。

9、物理文件（File System）

实际存储MySQL数据库文件和一些日志文件等的系统，如Linux，Unix,Windows等。

 

## **查询流程图**

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA52.tmp.jpg) 

## 连接MySQL

​	连接MySQL操作是一个连接进程和MySQL数据库实例进行通信，从程序设计的角度来说，就是进程通信。

​	进程的通信方式包括：管道、命名管道、TCP/IP套接字、UDP套接字等，MySQL数据库提供的连接方式包括：

### **TCP/IP**

在 Python 语言环境下我们这样连接数据库。

In [1]: from mysql import connector

In[2]:cnx=connector.connect(host="172.16.192.100",port=3306,user="appuser",password="xxxxxx")

但是连接数据库的背后发生了什么呢？

当我们通过驱动程序（mysql-connector-python,pymysql）连接MySQL服务端的时候，就是把连接参数传递给驱动程序，驱动程序再根据参数会发起到MySQL服务端的TCP连接。

当TCP连接建立之后驱动程序与服务端之间会按特定的格式和次序交换数据包，数据包的格式和发送次序由MySQL协议规定。

MySQL 协议：

https://dev.mysql.com/doc/internals/en/client-server-protocol.html

整个连接的过程中MySQL服务端与驱动程序之间，按如下的次序发送了这些包。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA53.tmp.jpg) 

1、MySQL服务端向客户端发送一个握手包，包里记录了MySQL-Server的版本，默认的授权插件，密码盐值（auth-data）。

2、MySQL客户端发出ssl连接请求包（如果有必要的话）。

3、MySQL客户端发出握手包的响应包，这个包时记录了用户名，密码加密后的串，客户端属性，等等其它信息。

4、MySQL服务端发出响应包，这个包里记录了登录是否成功，如果没有成功也会给出错误信息。

### **命名管道**

### **共享内存**

### **UNIX套接字**

## **高可用架构**

因MySQL的开源属性，其高可用架构非常灵活，目前常用的主要有以下几种：

### **主从复制**

1、主从复制模式

这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是MySQL replication技术。为了达到更高的可用性，在实际的应用环境中，需要配合高可用集群软件keepalived来实现自动failover，否则，需要手工切换。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA54.tmp.jpg) 

### **MHA**

2、MHA（Master High Availability）

MHA是相对成熟的高可用解决方案，该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。搭建MHA时，要求一个集群必须最少有三台数据库服务器，一主二从（即一台master，一台备用master，另外一台slave）。

MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，或部署在一台slave节点上，MHA Node运行在每台MySQL服务器上。

运行时，MHA Manager会定时探测集群中的master节点，当master故障时，会自动将最新数据的slave提升为新的master，然后将其他所有slave重新指向新的master。整个故障转移过程对应用程序完全透明。整个切换过程如下：

从宕机崩溃的master保存二进制日志事件（binlog events）;

识别含有最新更新的slave；

应用差异的中继日志（relay log）到其他的slave；

应用从master保存的二进制日志事件（binlog events）；

提升一个slave为新的master；

使其他的slave连接新的master进行复制；

### **MGR**

3、MGR（MySQL Group Replication）

MGR是MySQL官方推荐的另一种高可用架构，复制组间的数据同步基于Paxos协议。

当客户端发起更新事务时，该事务先在本地执行，执行完成之后就要发起对事务的提交操作。在还没有真正提交之前，需要将产生的复制写集广播出去，复制到其它成员。如果冲突检测成功，组内决定该事务可以提交，其它成员可以应用，否则就回滚。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA64.tmp.jpg) 

组复制可以在两种模式下运行：

单主模式下，组复制具有自动选主功能，每次只有一个Server成员接受更新，其它成员只提供读服务。

多主模式下，所有的Server成员都可以同时接受更新，没有主从之分，成员角色是完全对等的。

# PostgreSQL

## **架构**

PostgreSQL 使用C/S模式提供服务。客户端和服务器可以在不同的主机上，通过TCP/IP进行网络连接，架构如下：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA75.tmp.jpg) 

1、主进程Postgres（常驻进程）

主进程是PostgreSQL启动时，第一个启动的进程Postgres。启动时，他会执行恢复、初始化共享内存，启动后台进程。当有客户端发起链接请求时，postgres会生成子进程，同时创建后端进程。

是整个数据库实例的总控进程，负责启动和关闭该数据库实例。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA76.tmp.jpg) 

2、Postgres(子进程)，子进程

Postgres接受前端请求，对数据库进行检索，最后返回结果。如请求是对数据库进行更新，会先记录日志（PostgreSQL称为WAL日志），以便宕机重启时的数据恢复。另外，日志会定期归档保存，以便需要时进行数据恢复。

 

3、后台进程（Background Process）

● Syslogger（系统日志）进程

将错误信息写到log日志中。

● BgWriter(后台)进程

周期性的将脏内存块写入文件。

● Checkpointer

当检查点出现时，将脏内存块写到数据文件

● WalWrite（预写式日志）进程

将WAL（Write Ahead Log预写式日志）缓存写入WAL文件。

● PgArch（归档）进程

在归档模式下时，复制WAL文件到特定的路径下。

WAL日志会被循环使用，PgArch在归档前会把WAL日志备份出来。通过PITY（Point in Time Recovery）技术，可以对数据库进行一次全量备份后，该技术将备份时间点之后的WAL日志通过归档进行备份，使用数据库的全量备份再加上后面产生的WAL日志，即可把数据库向前推到全量备份后的任意一个时间点。

● AutoVacuum（自动清理）进程

当自动vacuum被启用时，用来派生autovacuum工作进程。autovacuum进程的作用是在需要时自动对膨胀表执行vacuum操作。

在PostgreSQL数据库中，对表进行DELETE操作后，旧的数据并不会立即被删除，并且，在更新数据时，也并不会在旧的数据上做更新，而是新生成一行数据。旧的数据只是被标识为删除状态，只有在没有并发的其他事务读到这些就数据时，它们才会被清楚。这个清除工作就有AutoVacuum进程完成。

● PgStat（统计数据收集）进程

用来收集数据库统计信息。

4、共享内存和本地内存

示意图如下：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wpsDA77.tmp.jpg) 

● 共享内存

PostgreSQL启动后，会生成一块共享内存，用于做数据块的缓冲区，以便提高读写性能。WAL日志缓冲区和Clog缓冲区也存在共享内存中，除此之外还有全局信息比如进程、锁、全局统计等信息也保存在共享内存中。

数据缓冲区通过BgWrite进程，定期将数据写入数据文件。WAL缓冲区通过WALWrite进程写入WAL文件，并通过PgArch定期进行归档，写入归档日志

● 本地内存

非全局存储的数据都存在本地内存中，主要包括：

临时缓冲区：用于临时表。默认值为8MB

work_mem: 用于排序、位图索引、哈希链接和合并链接操作。默认值为4MB。

manintance_work_mem: 用于vacuum和创建索引操作。默认值为64MB。

 

## **数据结构**

1、数据库相关概念：

PostgreSQL由一系列数据库组成。一套PostgreSQL程序称之为一个数据库群集。

当initdb()命令执行后，template0 , template1 , 和postgres数据库被创建。

template0和template1数据库是创建用户数据库时使用的模版数据库，他们包含系统元数据表。

initdb()刚完成后，template0和template1数据库中的表是一样的。但是template1数据库可以根据用户需要创建对象。

用户数据库是通过克隆template1数据库来创建的；

 

2、表空间相关概念：

initdb()后，创建pg_default和pg_global表空间。

建表时如果没有指定特定的表空间，表默认被存在pg_default表空间中。

用于管理整个数据库集群的表默认被存储在pg_global表空间中。

pg_default表空间的物理位置为$PGDATAbase目录。

pg_global表空间的物理位置为$PGDATAglobal目录。

一个表空间可以被多个数据库同时使用。此时，每一个数据库都会在表空间路径下创建为一个新的子路径。

创建一个用户表空间会在$PGDATApg_tblspc目录下面创建一个软连接，连接到表空间制定的目录位置。

 

3、表相关概念：

每个表有三个数据文件：

一个文件用于存储数据（文件名是表的OID）；

一个文件用于管理表的空闲空间（文件名是OID_fsm）。

一个文件用于管理表的块是否可见（文件名是OID_vm）。

索引没有_vm文件，只有OID和OID_fsm两个文件

 

## **后端进程的处理流程**

接收前端发送过来的查询(SQL文)

构文解析。将SQL文（单纯的文字）转换成构文树parser tree。

构文树解析完以后，换为查询树。这时会访问数据库，检查表是否存在，如果存在的话，则把表名转换为OID。这个处理称为分析处理(Analyze)。

因PostgreSQL还通过查询语句的重写实现视图(view)和规则(rule)，所以需要时，此阶段会对查询语句进行重写。

解析查询树后，可生成计划树。

按照执行计划里面的步骤可以完成查询要达到的目的。

执行结果返回给前端。

返回到步骤一重复执行。