# SQL生命周期

1、应用服务器与数据库服务器建立一个连接

2、数据库进程拿到请求sql

3、解析并生成执行计划，执行

4、读取数据到内存并进行逻辑处理

5、通过步骤一的连接，发送结果到客户端

6、关掉连接，释放资源

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F0C.tmp.jpg) 

# SELECT查询

## **基本语法**

SELECT语句的基本语法可以分成几个特定的子句。通过每个子句细化查询，以便返回需要的数据。SELECT语句的完整语法如下。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F0D.tmp.jpg) 

我们可以看出，必需的子句只有SELECT子句和FROM子句，其他的子句都是可选的。各子句具体含义如下。

• 关键词SELECT后面输入要显示的字段清单。**SELECT子句包含可选关键字DISTINCT和ALL。**在需要删除查询结果中相同的行时，我们使用关键字DISTINCT；在需要返回查询结果中的所有行时，使用关键字ALL。**如果没有指定任何一个关键字，那么关键字ALL就是默认的关键字。**

• FROM子句包括关键字FROM和一个或多个表结构。**如果表结构不止一个，那么它们之间必须用逗号分开。**一般情况下，表结构是表的名称，但也可以是一种子查询。在WHERE子句中列出搜索标准，用于选择要显示的数据行。如果SELECT语句没有WHERE子句，DBMS假设目标表中的所有行都满足搜索条件。

• GROUP BY子句用于分组查询结果，根据group_by_expression中列出的列，归纳信息类型，汇总相关数据。

• HAVING子句列出另外的行选择标准，以便根据GROUP BY子句产生的结果筛选行。

• ORDER BY子句接受SELECT子句的输出，并且按照ORDER BY子句中的规范对查询结果进行排列。这里的规范就是ASC和DESC关键字。ASC关键字表示升序排列结果，DESC关键字表示降序排列结果。如果没有指定任何一个关键字，那么ASC就是默认的关键字。如果没有ORDER BY子句，DBMS将根据输入表中的数据来显示数据。

 

## **查询条件**

### **组合条件查询**

#### AND运算符

在WHERE子句中，AND运算符表示“与”的关系，即AND在结合两个布尔表达式时，只有当两个表达式都为True时才传回True，从而使整个WHERE子句求值为True。

注：NULL与Fasle进行AND运算时，结果为False而不是NULL。两个表达式的顺序不影响其结果，也就是说，True和False取AND运算的结果与False和True的结果相同。

#### OR运算符

OR运算符表示“或”的关系。当可能有多个条件为True，但只要有一个为True就满足搜索要求时，我们可以使用OR运算符来组合搜索条件。OR在结合两个布尔表达式时，只要其中一个条件为True，便传回True。

注：NULL与True进行OR运算时，结果为True而不是NULL。

#### AND、OR运算符的组合

使用在WHERE子句中，AND、OR运算符可以同时连接多个条件，当然AND、OR运算符也可以同时使用。但是当AND、OR运算符同时存在时，其优先级如何确定呢？与大多数语言一样，**SQL语言认为AND运算符的运算级别要高于OR运算符**。即当出现：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F0E.tmp.jpg) 

时，其运算实际上是等价于

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F0F.tmp.jpg) 

因此，AND、OR运算符需要同时使用时，我们一定要注意运算符的优先级。

注：**当OR运算符和AND运算符同时运用时，建议用户不要考虑其默认的优先级顺序，而是采用括号“()”来实现需要的执行顺序，这样可以增强程序的可读性**。

### **IN运算符**

IN运算符允许根据一行记录中是否有一列包括在一系列值之中而选择该行。语法如下。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F20.tmp.jpg) 

所有的条件在IN运算符后面罗列，并以括号“()”包括起来，条件中间用逗号分开。当testexpression处于括号中列出的一系列值之中时，IN运算符求值为True。

与IN运算符相对的还有NOT IN运算符，其判别结果刚好与IN运算符相反，即当test expression不处于括号中列出的一系列值之中时，NOT IN运算符求值为True。

**在大多数情况下，OR运算符与IN运算符可以实现相同的功能。**

例如：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F21.tmp.jpg) 

等价于：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F22.tmp.jpg) 

我们可以发现二者结果完全相同。那么为什么要提出IN运算符呢？这是因为与OR运算符相比，IN运算符具有以下两个优点。

• 当选择的条件很多时，采用IN运算符就显得很简便，只需在括号内用逗号间隔依次罗列即可，运行效率比OR运算符要高。

• **使用IN运算符，其后面所列的条件可以是另一条SELECT语句，即子查询**。

 

### **NOT运算符**

NOT运算符用于对搜索条件的布尔值求反。本节将讨论NOT运算符的使用、应用场合及其与<>运算符的区别。

注：**NULL值进行取反，结果仍是NULL**。

对于简单的条件查询，NOT运算符与<>运算符的功能几乎没有什么区别，那么NOT运算符的优势体现在哪里呢？答案是它可以与其他运算符组合使用，这一点是<>运算符所不能实现的。

注：**MySQL数据库系统不支持NOT运算符。在MySQL数据库系统中，NOT运算符只能被用在EXISTS运算符的前面，形如NOT EXISTS**。

 

### **LIKE模糊查询**

在实际应用中我们经常要用到模糊查询，根据某一关键词搜索相关信息，在SQL语言中是通过通配符来实现的。SQL语言提供的通配符有“%”、“-”和“[]”，还包括前面介绍的“*”。

要在查询语句中使用通配符，我们必须使用LIKE运算符。要使用一个或多个通配符在LIKE查询中搜索字符串，只要将字符串与通配符组合起来即可。在数据库管理系统中，LIKE运算符与通配符组合使用可实现模糊查询功能。

注：**只有CHAR、VARCHAR和TEXT类型的数据才能使用LIKE运算符和通配符**。

#### “%”通配符

SQL语言中最常用的通配符可能就是“%”了，它表示任意字符的匹配，且不计字符的多少。

注：Microsoft Access数据库中不能使用“％”，其功能由“*”通配符所替代。

#### *“_”通配符*

“_”通配符的功能与“%”通配符基本相同，但是它只表示任意一个字符的匹配。当然，要表示两个字符的匹配，就需要使用两个“_”通配符，即写成“_ _”。

用户只有在确定所要查询的字符串的个数、只是不确定其中的一个或几个字符的确切值时，才能使用“_”通配符。

与“%”通配符相似，“_”通配符可以用在字符串的任意位置。当然，如果用户只知道要查询的字符串个数，而不能确定其中任何一个字符时，也可以使用“_”通配符。

#### []”通配符

“[]”通配符用于指定一系列的字符，只要满足这些字符其中之一且位置出现在“[]”通配符的位置，字符串就满足查询条件。

当然，各种通配符也可以组合使用。组合使用各种通配符时，我们一定要弄清其表示的匹配条件。如"LIKE '5[%]'"，其中“[]”通配符内的“%”就不能理解为“%”通配符，而只是表示“%”字符。

#### 使用ESCAPE定义转义符

在使用LIKE关键字进行模糊查询时，“%”、“_”和“[]”单独出现则会被认为是通配符。为了在字符数据类型的列中查询是否存在百分号（%）、下划线（_）或者方括号（[]）字符，我们就需要有一种方法告诉DBMS，将LIKE表达式中的这些字符看作是实际值，而不是通配符。关键字ESCAPE允许确定一个转义字符，告诉DBMS紧跟在转义字符之后的字符看作是实际值。如下面的表达式所示。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F32.tmp.jpg) 

这里使用ESCAPE关键字定义了转义字符“M”，告诉DBMS将搜索字符串“%M%”中的第二个百分号（%）作为实际值，而不是通配符。当然，第一个百分号（%）仍然被看作是通配符，因此满足该查询条件的字符串为所有以“%”结尾的字符串。

## **执行顺序**

在连接过程中，MySQL各关键字执行的顺序如下：

from -> on|using ->where -> group by -> having ->select ->order by -> limit

可以看到，连接的条件是先于where的，也就是先连接获得结果集后，才对结果集进行where筛选，所以在使用join的时候，我们要尽可能提供连接的条件，而少用where的条件，这样才能提高查询性能。

**具体分析：**

1、FROM：对FROM子句中的前两个表执行笛卡尔积（交叉联接），生成虚拟表VT1。

2、ON：对VT1应用ON筛选器，只有那些使为真才被插入到TV2。

3、OUTER（JOIN）：如果指定了OUTER JOIN（相对于CROSS JOIN或INNER JOIN），保留表中未找到匹配的行将作为外部行添加到 VT2，生成TV3。如果FROM子句包含两个以上的表，则对上一个联接生成的

结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表位置。

4、WHERE：对TV3应用WHERE筛选器，只有使为true的行才插入TV4。

5、GROUP BY：按GROUP BY子句中的列列表对TV4中的行进行分组，生成TV5。

6、CUTE|ROLLUP：把超组插入VT5，生成VT6。

7、HAVING：对VT6应用HAVING筛选器，只有使为true的组插入到VT7。

8、SELECT：处理SELECT列表，产生VT8。

9、DISTINCT：将重复的行从VT8中删除，产品VT9。

10、ORDER BY：将VT9中的行按ORDER BY子句中的列列表顺序，生成一个游标(VC10)。

11、TOP：从VC10的开始处选择指定数量或比例的行，生成表TV11，并返回给调用者。

 

# SELECT 1与SELECT null

select 1是增加临时列，每行的列值是写在select后面的数。Select null与select 1类似，只不过返回的列值为NULL，在与exists配合使用时，只要有行返回，则exists子查询仍然为true。

和select 1不同的是，select null不可能使用count和sum函数。

Null是一个特殊的值，既不是空也不是空格，而是一个不确定的值。

select null from t1 where id=1;语句的函数以是t1有几行满足id=1的值就返回几行null值。

 

# SELECT COUNT()/COUNT(1)

## **概述**

对于SQL：

SELECT COUNT(*) FROM tb;

SELECT COUNT(1) FROM tb;

会造成全表扫描，但是这种说法是有问题的，实际上针对无where_clause的 COUNT(*)，MySQL是有优化的，优化器会选择成本最小的辅助索引查询计数，其实反而性能最高。

找一个大表explain查看：

EXPLAIN SELECT COUNT(*) FROM tb;

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F33.tmp.jpg) 

发现确实此条语句在此例中用到的并不是主键索引，而是辅助索引，不管是COUNT(1)，还是COUNT(*)，MySQL都会用成本最小的辅助索引查询方式来计数，也就是使用COUNT(*) 由于MySQL的优化已经保证了它的查询性能是最好的！随带提一句，COUNT(*)是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用COUNT(*)查询表的行数！

但有个前提，在MySQL 5.6之后的版本中才有这种优化。

 

## **原理**

MyISAM引擎会把一个表的总行数记录了下来，所以在执行 count(*) 的时候会直接返回数量，执行效率很高。在MySQL 5.5以后默认引擎切换为InnoDB，InnoDB因为增加了版本控制（MVCC）的原因，同时有多个事务访问数据并且有更新操作的时候，每个事务需要维护自己的可见性，那么每个事务查询到的行数也是不同的，所以不能缓存具体的行数，他每次都需要 count 一下所有的行数。

 

MySQL COUNT(*) 在2种存储引擎中的部分问题：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F34.tmp.jpg) 

参考：

https://blog.didiyun.com/index.php/2019/01/08/mysql-count/

 

### **InnoDB**

在InnoDB中，使用COUNT(*)查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。

从MySQL 8.0.13开始，针对InnoDB的SELECT COUNT(*) FROM tbl_name语句，确实在扫表的过程中做了一些优化。前提是查询语句中不包含WHERE或GROUP BY等条件。

我们知道，COUNT(*)的目的只是为了统计总行数，所以，它根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。

我们知道，InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

所以，相比之下，***\*非聚簇索引要比聚簇索引小很多，所以MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的\****。

至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。

 

### **MyISAM**

MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的COUNT(*)有关，那就是MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。

因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用COUNT(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。

MyISAM之所以可以把表中的总行数记录下来供COUNT(*)查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。

对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。

### **区别**

count(*)有些不同，它返回取回的行的行数的计数，无论它们是否包含NULL值。

对于诸如InnoDB之类的事务存储引擎，存储精确的行数是有问题的。多个事务可能同时发生，每个事务都可能影响计数。

所以InnoDB不在内部保留表的行数，因为并发事务可能同时“看到”不同数量的行。因此，SELECT COUNT(*)语句只计算当前事务可见的行。

在MySQL 5.7.18之前，InnoDB通过扫描聚集索引（clustered index）来处理SELECT COUNT(*)语句。从MySQL 5.7.18开始，InnoDB通过遍历最小的可用二级索引来处理SELECT COUNT(*)语句，除非索引或优化器提示指示优化器使用不同的索引。如果不存在辅助索引，则扫描聚集索引。

如果索引记录不完全在缓冲池中，那么处理select count(*)语句需要一些时间。为了更快地计算，可以创建一个计数表，让应用程序根据插入和删除操作更新它。但是，在数千个并发事务正在启动对同一计数器表的更新的情况下，此方法可能无法很好地扩展。因此，如果大概的行数可以满足需求，请使用SHOW TABLE STATUS。

 

对于MyISAM表，如果SELECT从一个表没有检索到其他列，并且没有WHERE子句，而只返回COUNT(*)的结果，则COUNT(*)会被优化，可以快速返回。例如：

SELECT COUNT(*) FROM student;

此优化仅适用于MyISAM表，因为为此存储引擎存储了精确的行数，并且可以非常快速地访问。COUNT(1)则仅在第一列定义为NULL时，受到相同额度优化。

 

## **性能对比**

### **count(\*)与count(1)**

InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.

对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！***\*建议使用COUNT(\*)！因为这个是SQL92定义的标准统计行数的语法\****。

 

### **count(column)**

count(column)也是会遍历整张表，但是不同的是它会拿到column的值以后判断是否为空，非空的情况下再进行累加，那么如果针对主键需要解析内容，如果是二级所以需要再次根据主键获取内容，又是一次IO操作，相比COUNT(*)，COUNT(字段)多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(*)慢。

如果按照效率比较的话：count(*)=count(1)>count(primary key)>count(column)

既然count(*)在查询上依赖于所有的数据集，是不是我们在设计上也需要尽量的规避全量count呢？通常情况我们针对可预见的count查询会做适当的缓存，可以是Redis，也可以是独立的MySQL count表，当然无论是哪种方式我们都需要考虑一致性的问题。

### **对比**

count(primary key)：遍历整个表，把主键值拿出来，累加；

count(1)：遍历整个表，但是不取值，累加；

count(非空字段)：遍历整个表，读出这个字段，累加；

count(可以为空的字段)：遍历整个表，读出这个字段，判断不为null累加；

count(*)：遍历整个表，做了优化，不取值，累加。

结合mysql的一些索引查询知识，我们可以大致得出如下结论。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F45.tmp.jpg)

建议直接使用count(*)。

 

## **优化**

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F46.tmp.jpg) 

### **数据量大/准确性要求低/请求量大**

1、这种场景一般是C端产品，比如上面说的得到APP的订阅数目，如果对一致性要求不高，可以直接在内存中使用缓存，用guava在内存中做一个缓存定时刷新即可，百万量级count(*)有缓存的频率还不至于有啥性能问题；

2、但是内存内缓存有一个问题就是不同服务器之间的缓存数量是不一致的，可以考虑用redis作为计数，一般这种场景是大多数同学遇到的，简单粗暴搞定即可；

3、用show table status。这个建议还是不要用了，翻了下mysql的doc，40%的误差概率，碰上就有点大了。

 

### **数据量大/准确性要求高/请求量一般**

这种场景一般出现在账务上，比如有多少人打款。而且估计DAU在亿级别的公司可能才会遇到。这里最关键的问题还是一致性的要求。在并发系统中，看看我们用redis，我们看看会出现什么样的一致性问题：

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F47.tmp.jpg) 

在T2的时间点的时候会出现数据不一致，B看到的是数据已经更新，但是数据库还没更新。我们就在想，如果放到一个事务里面，就可以完美解决这个问题了呀。由于事务，InnoDB不支持像MyISAM准确计数，解铃还须系铃人，所以我们建一个计数表（count_table）+事务，解这个问题了。

![img](file:///C:\Users\大力\AppData\Local\Temp\ksohtml\wps9F58.tmp.jpg) 

在T1的时候，如果采用MySQL默认的事务隔离级别：读提交。因为T1事务还没有提交，所以插入的数据，B是读不到的，所以从逻辑上来说是一致的。

 

### **数据量大/准确性要求高/请求量特别高**

可能需要重新设计架构。

### **带条件count(\*)**

很多时候我们的业务场景不是数据量多，而是条件复杂。这其实就是一个查询优化的问题了，和是不是count(*)没有关系，那么有以下两招常用，这个得具体问题具体分析了。比如时间维度可以加一个索引来优化；

select * from table_name where a = x and b = x;

1、加索引

2、业务拆分

 

 